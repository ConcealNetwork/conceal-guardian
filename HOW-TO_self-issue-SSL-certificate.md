# Remote node over https

## Table of Contents

1. [Preamble](#1-preamble)

2. [Prerequisite](#2-prerequisite)  
a. [skills](#a-skills)  
b. [Domaine Name](#b-domain-name)  

3. [Self issue SSL certificate](#3-self-issue-ssl-certificate)
    * [Manage DNS Zone](#manage-dns-zone)
4. [From http to https](#4-from-http-to-https)  
a. [SSL Certificate](#a-ssl-certificate)  
b. [Reverse proxy with Apache](#b-reverse-proxy-with-apache)  
    - [Install Apache](#install-apache)  
    - [Configure Virtual Host](#configure-virtual-host)  
    - [Adding SSL module](#adding-ssl-module)  
    - [Redirect http to https](#redirect-http-to-https)  

5. [Broadcast](#5-broadcast)
6. [Final Test](#6-final-test)


  

## 1. Preamble

This tutorial aims to provide guidance to self-issue SSL certifificate for your node being accessible via https. The general method to reverse proxy your node over https is provided in the [HOW-TO_HTTPS.md](./HOW-TO_HTTPS.md) tutorial.  
Self-issuing certificate has some benefits:  
* save some money (in case the domain name provider charge for this service)
* allow automatisation of the renewal process 
* generates .pem files mor commun nowadays than .key or .crt

**This tutorial has been elaborated and tested on Ubuntu 22.04, and should also work on other Debian system**

## 2. Prerequisite

### a. Skills  
You should be familiar with terminal command usage, navigation to folders and working with files.

### b. Domain Name 
you have acquired a domain name and opt to issue the SSL certificate on your own. So you would be at step 4.a. of [HOW-TO_HTTPS.md](./HOW-TO_HTTPS.md) tutorial. 
   
Let’s say you acquired *your_domain.xyz* and planning to use Apache to serve your virtualhost.

  
## 3. Self issue SSL certificate

We'll use Certbot to facilitate our task. Cerbot is a client of [Let's Encrypt](https://letsencrypt.org/) API. you can find more information about Cerbot on their website [https://certbot.eff.org](https://certbot.eff.org). 
  
### a. Certbot installation
 

As we'll use the snap version of certbot, make sure any previous version installed with apt are removed.
* remove apt installed version if needed:
```
sudo apt-get remove certbot
```
* install snap version:
```
sudo snap install --classic certbot
```
* making sure cerbot command can be run:
```
sudo ln -s /snap/bin/certbot /usr/bin/certbot
```
we'll use cerbot only to generate certificate but not to  intervene in our Apache config file:
```
sudo certbot certonly --apache
```







First we'll configure a http server and then modify it to redirect to https, for which we'll need to implement SSL adding a certificate. Two options to get a SSL certificate :

* provided by your Domain Name provider  
or
* Generated by yourself, using `certbot`, `letsencrypt`  

We will use the first option and download the certificate. You should end up with two files: [^1]  
[^1]: if using *certbot* you would get 4 files with .pem extension.
* your_domain.xyz.key  (or privkey.pem)
* your_domain.xyz.crt  (or fullchain.pem)
  
(you should be able to generate a certificate with a wildcard, ie  `*.your_domain.xyz`)  
  

Store them in a folder requiring superior privileges like: [^2]  
[^2]: letsencrypt or cerbot would locate those file at the mention path, so for consistency we placed our files in the same folder. Another place would be `/etc/Apache2/ssl/`  

`/etc/letsencrypt/live/conceal.your_domain.xyz/`  

:warning: the folder where the key is store should be owned by `root` and the .key file be in read and write only for `root`  
- if needed  
```
sudo chmod 600 your_domain.xyz.key   
sudo chown -R root:root conceal.your_domain.xyz/  
```
 
 

### b. Reverse proxy with Apache

The express nodejs server running on port 16000 doesn’t handle https connection, so we’ll use an Apache server to do it with a reverse proxy method.

#### Install Apache
```
sudo apt install apache2
```

* enable proxy modules :
```
sudo a2enmod proxy proxy_http
```

* Restart your Apache service:
```
systemctl restart apache2
```

  
#### Configure Virtual Host

go in following folder:
```
cd /etc/apache2/sites-available
```

* create a file with your configuration: [^3]  
[^3]: some default configuration are already there, you might consider delete them or disable them ie. `sudo a2dissite 000-default.conf`
```
sudo nano conceal-your_domain-xyz.conf
```

* paste the following, and replace with your domain name:
```
<VirtualHost *:80>
ServerName conceal.your_domain.xyz
ServerAlias conceal.your_domain.xyz
ServerAdmin your@email.com

ProxyPreserveHost On
ProxyPass / http://localhost:16000/
ProxyPassReverse / http://localhost:16000/

ErrorLog /var/log/apache2/error.log
CustomLog /var/log/apache2/access.log combined

</VirtualHost>
```
**Important:** make sure the name in the certificate match the ServerName  
  

* save and enable your config:
```
sudo a2ensite conceal-your_domain-xyz.conf
```

* reload and restart the server with the following commands:
```
sudo systemctl reload apache2
sudo systemctl restart apache2
```
  
now you should be able to access your node from any web browser, using the url : `http://conceal.your_domain.xyz/`
test it with `http://conceal.your_domain.xyz/getinfo`  

#### Adding SSL module

enable SSL on apache:

```
sudo a2enmod ssl headers
```
  
#### Redirect http to https
Lets' modify our config file to redirect the http request to https and to include the certificate information:
still within `/etc/apache2/sites-available`
```
sudo nano conceal-your_domain-xyz.conf
```
and modify the file to reflect the following changes (uncomment, removing #, if you want to change options):
```
<VirtualHost *:80>

ServerName conceal.your_domain.xyz
ServerAlias conceal.your_domain.xyz
ServerAdmin your_mail@mail.com

Redirect permanent / https://conceal.your_domain.xyz

ErrorLog /var/log/apache2/error.log
CustomLog /var/log/apache2/access.log combined

</VirtualHost>
<VirtualHost *:443>

ServerName conceal.your_domain.xyz
ServerAlias conceal.your_domain.xyz
ServerAdmin your_mail@mail.com

ProxyPreserveHost On
ProxyPass / http://localhost:16000/
ProxyPassReverse / http://localhost:16000/
 
ServerSignature Off

# SSL Engine Switch:
# Enable/Disable SSL for this virtual host.
SSLEngine on

# Disable untrusted protocols (SSL v2, SSL v3)
SSLProtocol All -SSLv3 -SSLv2

# Disable unsecured encryption methods (using!)

SSLCipherSuite ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RS>

# We let the web-browser select the best choice
SSLHonorCipherOrder on

# Activation of HSTS (HTTP Strict Transport Security).
Header always set Strict-Transport-Security "max-age=15768000; includeSubDomains"

# other Header settings for CORS
Header always set Access-Control-Allow-Headers "*"
Header always set Access-Control-Allow-Methods "GET,POST,OPTIONS" 

# Certbot (automatique certification) or Letsencrypt from DomainName provider

SSLCertificateFile /etc/letsencrypt/live/conceal.your_domain.xyz/your_domain.xyz.crt
SSLCertificateKeyFile /etc/letsencrypt/live/conceal.your_domain.xyz/your_domain.xyz.key

  

# SSL Engine Options:
# Set various options for the SSL engine.
# o FakeBasicAuth:
# Translate the client X.509 into a Basic Authorisation. This means that
# the standard Auth/DBMAuth methods can be used for access control. The
# user name is the `one line' version of the client's X.509 certificate.
# Note that no password is obtained from the user. Every entry in the user
# file needs this password: `xxj31ZMTZzkVA'.
# o ExportCertData:
# This exports two additional environment variables: SSL_CLIENT_CERT and
# SSL_SERVER_CERT. These contain the PEM-encoded certificates of the
# server (always existing) and the client (only existing when client
# authentication is used). This can be used to import the certificates
# into CGI scripts.
# o StdEnvVars:
# This exports the standard SSL/TLS related `SSL_*' environment variables.
# Per default this exportation is switched off for performance reasons,
# because the extraction step is an expensive operation and is usually
# useless for serving static content. So one usually enables the
# exportation for CGI and SSI requests only.
# o StrictRequire:
# This denies access when "SSLRequireSSL" or "SSLRequire" applied even
# under a "Satisfy any" situation, i.e. when it applies access is denied
# and no other module can change it.
# o OptRenegotiate:
# This enables optimized SSL connection renegotiation handling when SSL
# directives are used in per-directory context.
#SSLOptions +FakeBasicAuth +ExportCertData +StrictRequire
<FilesMatch "\.(cgi|shtml|phtml|php)$">
 SSLOptions +StdEnvVars
</FilesMatch>
<Directory /usr/lib/cgi-bin>
 SSLOptions +StdEnvVars
</Directory>

# SSL Protocol Adjustments:
# The safe and default but still SSL/TLS standard compliant shutdown
# approach is that mod_ssl sends the close notify alert but doesn't wait for
# approach you can use one of the following variables:
# o ssl-unclean-shutdown:
# This forces an unclean shutdown when the connection is closed, i.e. no
# SSL close notify alert is send or allowed to received. This violates
# the SSL/TLS standard but is needed for some brain-dead browsers. Use
# this when you receive I/O errors because of the standard approach where
# mod_ssl sends the close notify alert.
# o ssl-accurate-shutdown:
# This forces an accurate shutdown when the connection is closed, i.e. a
# SSL close notify alert is send and mod_ssl waits for the close notify
# alert of the client. This is 100% SSL/TLS standard compliant, but in
# practice often causes hanging connections with brain-dead browsers. Use
# this only for browsers where you know that their SSL implementation
# works correctly.
# Notice: Most problems of broken clients are also related to the HTTP

# keep-alive facility, so you usually additionally want to disable
# keep-alive for those clients, too. Use variable "nokeepalive" for this.
# Similarly, one has to force some clients to use HTTP/1.0 to workaround
# their broken HTTP/1.1 implementation. Use variables "downgrade-1.0" and
# "force-response-1.0" for this.
BrowserMatch "MSIE [2-6]" \
nokeepalive ssl-unclean-shutdown \
downgrade-1.0 force-response-1.0
# MSIE 7 and newer should be able to use keepalive
BrowserMatch "MSIE [17-9]" ssl-unclean-shutdown

ErrorLog /var/log/apache2/error.log
CustomLog /var/log/apache2/access.log combined

</VirtualHost>
```

save and check configuration :

```
sudo apache2ctl configtest
```
you may obtain the following output, which is fine:  
`AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 127.0.1.1. Set the 'ServerName' directive globally to suppress this message
Syntax OK`  

reload and restart
```
sudo systemctl reload apache2
sudo systemctl restart apache2
```
  
you can test with:
```
https://conceal.your_domain.xyz/getinfo
```
  
## 5. Broadcast

Within **conceal-guardian** folder, modify your **config.json** file to include the following parameters :

```
"url": {
"host": "conceal.your_domain.xyz",
"port": ""
}
```
  
and restart Conceal-guardian. if you're using a service to launch, it should be something like :
```
sudo systemctl restart ccx-guardian.service
```
  
 
## 6. Final Test
in a web wallet, go in **Settings** tab, toggle the switch **Use custom node** and fill with the url : `https://conceal.your_domain.xyz/`

an other way to test, is to check if your node is listed in the [Conceal Network explorer page json file](https://explorer.conceal.network/pool/list?hasFeeAddr=true&isReachable=true&hasSSL=true)
  
  
  

this complete this tutorial.
  
### Notes:
 We decided to proceed in two steps, first create the http reverse proxy and then redirect it to https, for educational purpose and  also to allow intermediate testing.  

Some circumpstances may increase the level of difficulty of this procedure and would need to be addressed, such as:
* ISP does not provide a fix IP
* self-issued cetificate
* certificate renewal