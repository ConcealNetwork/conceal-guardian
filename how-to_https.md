# Remote node over https

  

## Table of Contents

* [Preamble](#preamble)

* [Prerequisite](#prerequisite)
	* [Conceal Guardian](#conceal-guardian)
	* [Port Forwarding](#port-forwarding)
	* [Firewall](#firewall)

* [Domain Name Provider](#domain-name-provider)
	* [Manage DNS Zone](#manage-dns-zone)

* [From http to https](#from-http-to-https)
	* [SSL Certificate](#ssl-certificate)
	* [Reverse proxy with Apache](#reverse-proxy-with-apache)
		* [Install Apache](#install-apache)
		* [Configure Virtual Host](#configure-virtual-host)
		* [Adding SSL module](#adding-ssl-module)
		* [Redirect http to https](#redirect-http-to-https)
* [Test](#test)

  
  

## Preamble

This tutorial aims to provide, step by step, the necessary actions required to allow your node to be accessible via http and https in particular. Such access is required for web wallet clients, it can potentially increase the revenue for the node operator, since more transactions would go through the node.
  
| your node is accessible | before the tutorial   | after this tutotial                |
| ----------------------- | --------------------- | ---------------------------------- |
| localy                  | localhost:16000       | localhost:16000                    |
| local network           | *your_local_ip*:16000 | *your_local_ip*:16000              |
| worldwide               | *global_ip*:16000     | *global_ip*:16000                  |
|                         |                       | http://subdomain.your_domain.xyz/  |
|                         |                       | https://subdomain.your_domain.xyz/ |
| Client compatibility    | desktop wallet        | web wallet                         |

**For the ease of this tutorial, let's assume:**

| IP of computer/server where the node is installed: | *your_local_ip* (ie. 192.168.0.11) |
| -------------------------------------------------- | ---------------------------------- |
| your router has a fix IP address:                  | *global_ip* (ie. 66.82.144.155)    |
| subdomain                                          | conceal                            |
| Domain Name                                        | your_domain.xyz                    |

**This tutorial has been elaborated and tested on Ubuntu 22.04, and should also work on other Debian system**

## Prerequisite

### Conceal Guardian
should be already up and running. Before moving forward, make sure you can access [localhost:16000/getinfo](localhost:16000/getinfo)

Modify your **config.json** file to include the following parameters :

```

"url": {

"host": "conceal.your_domain.xyz",

"port": ""

}

```

and restart Conceal-guardian. if you're using a service to launch, it should be something like :
```
sudo systemctl restart ccx-guardian.service
```
### Port Forwarding

on your router you probably already have port 16000 forwarded, you now have to add 80 and 443.

| port    | 16000           |
| ------- | --------------- |
| ip      | *your_local_ip* |
| TCP,UDP | Both            |

| port    | 80              |
| ------- | --------------- |
| ip      | *your_local_ip* |
| TCP,UDP | Both            |

| port    | 443             |
| ------- | --------------- |
| ip      | *your_local_ip* |
| TCP,UDP | Both            |

### Firewall

on the server running the Apache server, you'll need to allow connections :

`sudo ufw allow in "Apache Full"`

  

## Domain Name providers

Here is a list of domain name providers, note those who are including SSL certificate service. Pick one depending of your budget and/or location

[https://certbot.eff.org/hosting_providers/](https://certbot.eff.org/hosting_providers/)

Note that to save some money you only need the domain name, and don’t specifically need hosting service
If your domain name provider doesn't provide SSL certificate, you will have to self-issue it, which defeat the purpose on the trust level.  

For the purpose of this tutorial let’s say you acquired *your_domain.xyz*

### Manage DNS Zone

In your Domain Name provider website, you should have a **manage** tab associated with the domain name you just purchased. Add a subdomain  *(ie. conceal)* and have it pointing to your IPv4 *global_ip* address using the A record.

You can access your node via:

[conceal.your_domain.xyz:16000/getinfo](conceal.your_domain.xyz:16000/getinfo)

 
## From http to https

### SSL certificate
Now we need to implement SSL adding a certificate. Two options to get a ssl certificate :

* provided by your Domain Name provider

* Generated by yourself, using `certbot`, `openssl`

Will go with first option and download the certificate, you should end up with two files:
	* your_domain.xyz.key
	* your_domain.xyz.crt
Store them in a folder requiring superior privileges like:
`/etc/letsencrypt/live/conceal.your_domain.xyz/`  
### Reverse proxy with Apache

The express nodejs server running on port 16000 doesn’t handle https connection, so we’ll use an Apache server to do it with a reverse proxy method.

#### Install Apache
```
sudo apt install apache2
```

* enable proxy modules :
```
sudo a2enmod proxy proxy_http
```

Restart your Apache service:
```
systemctl restart apache2
```

  
#### Configure Virtual Host

go in following folder:
```
cd /etc/apache2/sites-available
```

create a file with your configuration:
```
sudo nano conceal-your_domain-xyz.conf
```

with following:
```
<VirtualHost *:80>
ServerName conceal.your_domain.xyz:16000
ServerAlias conceal.your_domain.xyz:16000
ServerAdmin your@email.com

ProxyPreserveHost On
ProxyPass / http://localhost:16000/
ProxyPassReverse / http://localhost:16000/

ErrorLog /var/log/apache2/error.log
CustomLog /var/log/apache2/access.log combined

</VirtualHost>
```

enable your config:
```
sudo a2ensite conceal-your_domain-xyz.conf
```

reload and restart the server with the following commands:
```
sudo systemctl reload apache2
sudo systemctl restart apache2
```
  
now you should be able to access your node from any web browser, using the url : `http://conceal.your_domain.xyz/`
test it with `http://conceal.your_domain.xyz/getinfo`

#### Adding SSL module

enable SSL on apache:

```
sudo a2enmod ssl
```
  
#### Redirect http to https
Lets' modify our config file to redirect the http request to https and to include the certificate information:
```
sudo nano conceal-your_domain-xyz.conf
```
and modify the file with following (uncomment, removing #, if you want to add more options):
```
<VirtualHost *:80>

ServerName conceal.your_domain.xyz
ServerAlias conceal.your_domain.xyz
ServerAdmin your_mail@mail.com

Redirect permanent / https://conceal.your_domain.xyz

ErrorLog /var/log/apache2/error.log
CustomLog /var/log/apache2/access.log combined

</VirtualHost>
<VirtualHost *:443>

ServerName conceal.your_domain.xyz
ServerAlias conceal.your_domain.xyz
ServerAdmin your_mail@mail.com

ProxyPreserveHost On
ProxyPass / http://localhost:16000/
ProxyPassReverse / http://localhost:16000/
 
ServerSignature Off

# SSL Engine Switch:
# Enable/Disable SSL for this virtual host.
SSLEngine on

# Disable untrusted protocols (SSL v2, SSL v3)
SSLProtocol All -SSLv3 -SSLv2

# Disable unsecured encryption methods (using!)

SSLCipherSuite ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RS>

# We let the web-browser select the best choice
SSLHonorCipherOrder on

# Activation of HSTS (HTTP Strict Transport Security).
# Header always set Strict-Transport-Security "max-age=15768000"

# Certbot (automatique certification) or Letsencrypt from DomainName provider

SSLCertificateFile /etc/letsencrypt/live/conceal.your_domain.xyz/your_domain.xyz.crt
SSLCertificateKeyFile /etc/letsencrypt/live/conceal.your_domain.xyz/your_domain.xyz.key

  

# SSL Engine Options:
# Set various options for the SSL engine.
# o FakeBasicAuth:
# Translate the client X.509 into a Basic Authorisation. This means that
# the standard Auth/DBMAuth methods can be used for access control. The
# user name is the `one line' version of the client's X.509 certificate.
# Note that no password is obtained from the user. Every entry in the user
# file needs this password: `xxj31ZMTZzkVA'.
# o ExportCertData:
# This exports two additional environment variables: SSL_CLIENT_CERT and
# SSL_SERVER_CERT. These contain the PEM-encoded certificates of the
# server (always existing) and the client (only existing when client
# authentication is used). This can be used to import the certificates
# into CGI scripts.
# o StdEnvVars:
# This exports the standard SSL/TLS related `SSL_*' environment variables.
# Per default this exportation is switched off for performance reasons,
# because the extraction step is an expensive operation and is usually
# useless for serving static content. So one usually enables the
# exportation for CGI and SSI requests only.
# o StrictRequire:
# This denies access when "SSLRequireSSL" or "SSLRequire" applied even
# under a "Satisfy any" situation, i.e. when it applies access is denied
# and no other module can change it.
# o OptRenegotiate:
# This enables optimized SSL connection renegotiation handling when SSL
# directives are used in per-directory context.
#SSLOptions +FakeBasicAuth +ExportCertData +StrictRequire
# <FilesMatch "\.(cgi|shtml|phtml|php)$">
# SSLOptions +StdEnvVars
# </FilesMatch>
# <Directory /usr/lib/cgi-bin>
# SSLOptions +StdEnvVars
# </Directory>

# SSL Protocol Adjustments:
# The safe and default but still SSL/TLS standard compliant shutdown
# approach is that mod_ssl sends the close notify alert but doesn't wait for
# approach you can use one of the following variables:
# o ssl-unclean-shutdown:
# This forces an unclean shutdown when the connection is closed, i.e. no
# SSL close notify alert is send or allowed to received. This violates
# the SSL/TLS standard but is needed for some brain-dead browsers. Use
# this when you receive I/O errors because of the standard approach where
# mod_ssl sends the close notify alert.
# o ssl-accurate-shutdown:
# This forces an accurate shutdown when the connection is closed, i.e. a
# SSL close notify alert is send and mod_ssl waits for the close notify
# alert of the client. This is 100% SSL/TLS standard compliant, but in
# practice often causes hanging connections with brain-dead browsers. Use
# this only for browsers where you know that their SSL implementation
# works correctly.
# Notice: Most problems of broken clients are also related to the HTTP

# keep-alive facility, so you usually additionally want to disable
# keep-alive for those clients, too. Use variable "nokeepalive" for this.
# Similarly, one has to force some clients to use HTTP/1.0 to workaround
# their broken HTTP/1.1 implementation. Use variables "downgrade-1.0" and
# "force-response-1.0" for this.
# BrowserMatch "MSIE [2-6]" \
# nokeepalive ssl-unclean-shutdown \
# downgrade-1.0 force-response-1.0
# MSIE 7 and newer should be able to use keepalive
# BrowserMatch "MSIE [17-9]" ssl-unclean-shutdown

ErrorLog /var/log/apache2/error.log
CustomLog /var/log/apache2/access.log combined

</VirtualHost>
```

save and check configuration :

```
sudo apache2ctl configtest
```
you may obtain one line of error and then an "OK" message.

reload and restart
```
sudo systemctl reload apache2
sudo systemctl restart apache2
```
  
you can test with:
```
https://conceal.your_domain.xyz/getinfo
```

## Test
in a web wallet, go in **Settings** tab, toggle the switch **Use custom node** and fill with the url : `https://conceal.your_domain.xyz/`
